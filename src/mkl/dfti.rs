
/* automatically generated by rust-bindgen */

pub const MKL_DOMAIN_ALL: u32 = 0;
pub const MKL_DOMAIN_BLAS: u32 = 1;
pub const MKL_DOMAIN_FFT: u32 = 2;
pub const MKL_DOMAIN_VML: u32 = 3;
pub const MKL_DOMAIN_PARDISO: u32 = 4;
pub const MKL_CBWR_BRANCH: u32 = 1;
pub const MKL_CBWR_ALL: i32 = -1;
pub const MKL_CBWR_STRICT: u32 = 65536;
pub const MKL_CBWR_OFF: u32 = 0;
pub const MKL_CBWR_BRANCH_OFF: u32 = 1;
pub const MKL_CBWR_AUTO: u32 = 2;
pub const MKL_CBWR_COMPATIBLE: u32 = 3;
pub const MKL_CBWR_SSE2: u32 = 4;
pub const MKL_CBWR_SSSE3: u32 = 6;
pub const MKL_CBWR_SSE4_1: u32 = 7;
pub const MKL_CBWR_SSE4_2: u32 = 8;
pub const MKL_CBWR_AVX: u32 = 9;
pub const MKL_CBWR_AVX2: u32 = 10;
pub const MKL_CBWR_AVX512_MIC: u32 = 11;
pub const MKL_CBWR_AVX512: u32 = 12;
pub const MKL_CBWR_AVX512_MIC_E1: u32 = 13;
pub const MKL_CBWR_AVX512_E1: u32 = 14;
pub const MKL_CBWR_SUCCESS: u32 = 0;
pub const MKL_CBWR_ERR_INVALID_SETTINGS: i32 = -1;
pub const MKL_CBWR_ERR_INVALID_INPUT: i32 = -2;
pub const MKL_CBWR_ERR_UNSUPPORTED_BRANCH: i32 = -3;
pub const MKL_CBWR_ERR_UNKNOWN_BRANCH: i32 = -4;
pub const MKL_CBWR_ERR_MODE_CHANGE_FAILURE: i32 = -8;
pub const MKL_CBWR_SSE3: u32 = 5;
pub const DFTI_NO_ERROR: u32 = 0;
pub const DFTI_MEMORY_ERROR: u32 = 1;
pub const DFTI_INVALID_CONFIGURATION: u32 = 2;
pub const DFTI_INCONSISTENT_CONFIGURATION: u32 = 3;
pub const DFTI_MULTITHREADED_ERROR: u32 = 4;
pub const DFTI_BAD_DESCRIPTOR: u32 = 5;
pub const DFTI_UNIMPLEMENTED: u32 = 6;
pub const DFTI_MKL_INTERNAL_ERROR: u32 = 7;
pub const DFTI_NUMBER_OF_THREADS_ERROR: u32 = 8;
pub const DFTI_1D_LENGTH_EXCEEDS_INT32: u32 = 9;
pub const DFTI_MAX_MESSAGE_LENGTH: u32 = 80;
pub const DFTI_MAX_NAME_LENGTH: u32 = 10;
pub const DFTI_VERSION_LENGTH: u32 = 198;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _MKL_Complex8 {
    pub real: f32,
    pub imag: f32,
}
#[test]
fn bindgen_test_layout__MKL_Complex8() {
    assert_eq!(
        ::std::mem::size_of::<_MKL_Complex8>(),
        8usize,
        concat!("Size of: ", stringify!(_MKL_Complex8))
    );
    assert_eq!(
        ::std::mem::align_of::<_MKL_Complex8>(),
        4usize,
        concat!("Alignment of ", stringify!(_MKL_Complex8))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_MKL_Complex8>())).real as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_MKL_Complex8),
            "::",
            stringify!(real)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_MKL_Complex8>())).imag as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_MKL_Complex8),
            "::",
            stringify!(imag)
        )
    );
}
pub type MKL_Complex8 = _MKL_Complex8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _MKL_Complex16 {
    pub real: f64,
    pub imag: f64,
}
#[test]
fn bindgen_test_layout__MKL_Complex16() {
    assert_eq!(
        ::std::mem::size_of::<_MKL_Complex16>(),
        16usize,
        concat!("Size of: ", stringify!(_MKL_Complex16))
    );
    assert_eq!(
        ::std::mem::align_of::<_MKL_Complex16>(),
        8usize,
        concat!("Alignment of ", stringify!(_MKL_Complex16))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_MKL_Complex16>())).real as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_MKL_Complex16),
            "::",
            stringify!(real)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_MKL_Complex16>())).imag as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_MKL_Complex16),
            "::",
            stringify!(imag)
        )
    );
}
pub type MKL_Complex16 = _MKL_Complex16;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MKLVersion {
    pub MajorVersion: ::std::os::raw::c_int,
    pub MinorVersion: ::std::os::raw::c_int,
    pub UpdateVersion: ::std::os::raw::c_int,
    pub ProductStatus: *mut ::std::os::raw::c_char,
    pub Build: *mut ::std::os::raw::c_char,
    pub Processor: *mut ::std::os::raw::c_char,
    pub Platform: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_MKLVersion() {
    assert_eq!(
        ::std::mem::size_of::<MKLVersion>(),
        48usize,
        concat!("Size of: ", stringify!(MKLVersion))
    );
    assert_eq!(
        ::std::mem::align_of::<MKLVersion>(),
        8usize,
        concat!("Alignment of ", stringify!(MKLVersion))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MKLVersion>())).MajorVersion as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MKLVersion),
            "::",
            stringify!(MajorVersion)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MKLVersion>())).MinorVersion as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(MKLVersion),
            "::",
            stringify!(MinorVersion)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MKLVersion>())).UpdateVersion as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MKLVersion),
            "::",
            stringify!(UpdateVersion)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MKLVersion>())).ProductStatus as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(MKLVersion),
            "::",
            stringify!(ProductStatus)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MKLVersion>())).Build as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(MKLVersion),
            "::",
            stringify!(Build)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MKLVersion>())).Processor as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(MKLVersion),
            "::",
            stringify!(Processor)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MKLVersion>())).Platform as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(MKLVersion),
            "::",
            stringify!(Platform)
        )
    );
}
pub const MKL_LAYOUT_MKL_ROW_MAJOR: MKL_LAYOUT = 101;
pub const MKL_LAYOUT_MKL_COL_MAJOR: MKL_LAYOUT = 102;
pub type MKL_LAYOUT = u32;
pub const MKL_TRANSPOSE_MKL_NOTRANS: MKL_TRANSPOSE = 111;
pub const MKL_TRANSPOSE_MKL_TRANS: MKL_TRANSPOSE = 112;
pub const MKL_TRANSPOSE_MKL_CONJTRANS: MKL_TRANSPOSE = 113;
pub type MKL_TRANSPOSE = u32;
pub const MKL_UPLO_MKL_UPPER: MKL_UPLO = 121;
pub const MKL_UPLO_MKL_LOWER: MKL_UPLO = 122;
pub type MKL_UPLO = u32;
pub const MKL_DIAG_MKL_NONUNIT: MKL_DIAG = 131;
pub const MKL_DIAG_MKL_UNIT: MKL_DIAG = 132;
pub type MKL_DIAG = u32;
pub const MKL_SIDE_MKL_LEFT: MKL_SIDE = 141;
pub const MKL_SIDE_MKL_RIGHT: MKL_SIDE = 142;
pub type MKL_SIDE = u32;
pub const MKL_COMPACT_PACK_MKL_COMPACT_SSE: MKL_COMPACT_PACK = 181;
pub const MKL_COMPACT_PACK_MKL_COMPACT_AVX: MKL_COMPACT_PACK = 182;
pub const MKL_COMPACT_PACK_MKL_COMPACT_AVX512: MKL_COMPACT_PACK = 183;
pub type MKL_COMPACT_PACK = u32;
pub type sgemm_jit_kernel_t =
    ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void,
                             arg2: *mut f32,
                             arg3: *mut f32,
                             arg4: *mut f32),
    >;
pub type dgemm_jit_kernel_t =
    ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void,
                             arg2: *mut f64,
                             arg3: *mut f64,
                             arg4: *mut f64),
    >;
pub type cgemm_jit_kernel_t =
    ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void,
                             arg2: *mut MKL_Complex8,
                             arg3: *mut MKL_Complex8,
                             arg4: *mut MKL_Complex8),
    >;
pub type zgemm_jit_kernel_t =
    ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void,
                             arg2: *mut MKL_Complex16,
                             arg3: *mut MKL_Complex16,
                             arg4: *mut MKL_Complex16),
    >;
pub const mkl_jit_status_t_MKL_JIT_SUCCESS: mkl_jit_status_t = 0;
pub const mkl_jit_status_t_MKL_NO_JIT: mkl_jit_status_t = 1;
pub const mkl_jit_status_t_MKL_JIT_ERROR: mkl_jit_status_t = 2;
pub type mkl_jit_status_t = u32;
pub const DFTI_CONFIG_PARAM_DFTI_FORWARD_DOMAIN: DFTI_CONFIG_PARAM = 0;
pub const DFTI_CONFIG_PARAM_DFTI_DIMENSION: DFTI_CONFIG_PARAM = 1;
pub const DFTI_CONFIG_PARAM_DFTI_LENGTHS: DFTI_CONFIG_PARAM = 2;
pub const DFTI_CONFIG_PARAM_DFTI_PRECISION: DFTI_CONFIG_PARAM = 3;
pub const DFTI_CONFIG_PARAM_DFTI_FORWARD_SCALE: DFTI_CONFIG_PARAM = 4;
pub const DFTI_CONFIG_PARAM_DFTI_BACKWARD_SCALE: DFTI_CONFIG_PARAM = 5;
pub const DFTI_CONFIG_PARAM_DFTI_NUMBER_OF_TRANSFORMS: DFTI_CONFIG_PARAM = 7;
pub const DFTI_CONFIG_PARAM_DFTI_COMPLEX_STORAGE: DFTI_CONFIG_PARAM = 8;
pub const DFTI_CONFIG_PARAM_DFTI_REAL_STORAGE: DFTI_CONFIG_PARAM = 9;
pub const DFTI_CONFIG_PARAM_DFTI_CONJUGATE_EVEN_STORAGE: DFTI_CONFIG_PARAM = 10;
pub const DFTI_CONFIG_PARAM_DFTI_PLACEMENT: DFTI_CONFIG_PARAM = 11;
pub const DFTI_CONFIG_PARAM_DFTI_INPUT_STRIDES: DFTI_CONFIG_PARAM = 12;
pub const DFTI_CONFIG_PARAM_DFTI_OUTPUT_STRIDES: DFTI_CONFIG_PARAM = 13;
pub const DFTI_CONFIG_PARAM_DFTI_INPUT_DISTANCE: DFTI_CONFIG_PARAM = 14;
pub const DFTI_CONFIG_PARAM_DFTI_OUTPUT_DISTANCE: DFTI_CONFIG_PARAM = 15;
pub const DFTI_CONFIG_PARAM_DFTI_WORKSPACE: DFTI_CONFIG_PARAM = 17;
pub const DFTI_CONFIG_PARAM_DFTI_ORDERING: DFTI_CONFIG_PARAM = 18;
pub const DFTI_CONFIG_PARAM_DFTI_TRANSPOSE: DFTI_CONFIG_PARAM = 19;
pub const DFTI_CONFIG_PARAM_DFTI_DESCRIPTOR_NAME: DFTI_CONFIG_PARAM = 20;
pub const DFTI_CONFIG_PARAM_DFTI_PACKED_FORMAT: DFTI_CONFIG_PARAM = 21;
pub const DFTI_CONFIG_PARAM_DFTI_COMMIT_STATUS: DFTI_CONFIG_PARAM = 22;
pub const DFTI_CONFIG_PARAM_DFTI_VERSION: DFTI_CONFIG_PARAM = 23;
pub const DFTI_CONFIG_PARAM_DFTI_NUMBER_OF_USER_THREADS: DFTI_CONFIG_PARAM = 26;
pub const DFTI_CONFIG_PARAM_DFTI_THREAD_LIMIT: DFTI_CONFIG_PARAM = 27;
pub const DFTI_CONFIG_PARAM_DFTI_DESTROY_INPUT: DFTI_CONFIG_PARAM = 28;
pub type DFTI_CONFIG_PARAM = u32; // u32
pub const DFTI_CONFIG_VALUE_DFTI_COMMITTED: DFTI_CONFIG_VALUE = 30;
pub const DFTI_CONFIG_VALUE_DFTI_UNCOMMITTED: DFTI_CONFIG_VALUE = 31;
pub const DFTI_CONFIG_VALUE_DFTI_COMPLEX: DFTI_CONFIG_VALUE = 32;
pub const DFTI_CONFIG_VALUE_DFTI_REAL: DFTI_CONFIG_VALUE = 33;
pub const DFTI_CONFIG_VALUE_DFTI_SINGLE: DFTI_CONFIG_VALUE = 35;
pub const DFTI_CONFIG_VALUE_DFTI_DOUBLE: DFTI_CONFIG_VALUE = 36;
pub const DFTI_CONFIG_VALUE_DFTI_COMPLEX_COMPLEX: DFTI_CONFIG_VALUE = 39;
pub const DFTI_CONFIG_VALUE_DFTI_COMPLEX_REAL: DFTI_CONFIG_VALUE = 40;
pub const DFTI_CONFIG_VALUE_DFTI_REAL_COMPLEX: DFTI_CONFIG_VALUE = 41;
pub const DFTI_CONFIG_VALUE_DFTI_REAL_REAL: DFTI_CONFIG_VALUE = 42;
pub const DFTI_CONFIG_VALUE_DFTI_INPLACE: DFTI_CONFIG_VALUE = 43;
pub const DFTI_CONFIG_VALUE_DFTI_NOT_INPLACE: DFTI_CONFIG_VALUE = 44;
pub const DFTI_CONFIG_VALUE_DFTI_ORDERED: DFTI_CONFIG_VALUE = 48;
pub const DFTI_CONFIG_VALUE_DFTI_BACKWARD_SCRAMBLED: DFTI_CONFIG_VALUE = 49;
pub const DFTI_CONFIG_VALUE_DFTI_ALLOW: DFTI_CONFIG_VALUE = 51;
pub const DFTI_CONFIG_VALUE_DFTI_AVOID: DFTI_CONFIG_VALUE = 52;
pub const DFTI_CONFIG_VALUE_DFTI_NONE: DFTI_CONFIG_VALUE = 53;
pub const DFTI_CONFIG_VALUE_DFTI_CCS_FORMAT: DFTI_CONFIG_VALUE = 54;
pub const DFTI_CONFIG_VALUE_DFTI_PACK_FORMAT: DFTI_CONFIG_VALUE = 55;
pub const DFTI_CONFIG_VALUE_DFTI_PERM_FORMAT: DFTI_CONFIG_VALUE = 56;
pub const DFTI_CONFIG_VALUE_DFTI_CCE_FORMAT: DFTI_CONFIG_VALUE = 57;
pub type DFTI_CONFIG_VALUE = u32; // u32
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DFTI_DESCRIPTOR {
    _unused: [u8; 0],
}
pub type DFTI_DESCRIPTOR_HANDLE = *mut DFTI_DESCRIPTOR;
extern "C" {
    pub fn DftiCreateDescriptor(
        arg1: *mut DFTI_DESCRIPTOR_HANDLE,
        arg2: DFTI_CONFIG_VALUE,
        arg3: DFTI_CONFIG_VALUE,
        arg4: ::std::os::raw::c_long,
        ...
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn DftiCopyDescriptor(
        arg1: DFTI_DESCRIPTOR_HANDLE,
        arg2: *mut DFTI_DESCRIPTOR_HANDLE,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn DftiCommitDescriptor(arg1: DFTI_DESCRIPTOR_HANDLE) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn DftiComputeForward(
        arg1: DFTI_DESCRIPTOR_HANDLE,
        arg2: *mut ::std::os::raw::c_void,
        ...
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn DftiComputeBackward(
        arg1: DFTI_DESCRIPTOR_HANDLE,
        arg2: *mut ::std::os::raw::c_void,
        ...
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn DftiSetValue(
        arg1: DFTI_DESCRIPTOR_HANDLE,
        arg2: DFTI_CONFIG_PARAM,
        ...
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn DftiGetValue(
        arg1: DFTI_DESCRIPTOR_HANDLE,
        arg2: DFTI_CONFIG_PARAM,
        ...
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn DftiFreeDescriptor(arg1: *mut DFTI_DESCRIPTOR_HANDLE) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn DftiErrorMessage(arg1: ::std::os::raw::c_long) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn DftiErrorClass(
        arg1: ::std::os::raw::c_long,
        arg2: ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_long;
}
extern "C" {# [ doc = " INTERNAL INTERFACES. These internal interfaces are not intended to" ] # [ doc = " be called directly by Intel(R) MKL users and may change in future releases." ]    pub fn DftiCreateDescriptor_s_1d(
        arg1: *mut DFTI_DESCRIPTOR_HANDLE,
        domain: DFTI_CONFIG_VALUE,
        ...
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn DftiCreateDescriptor_s_md(
        arg1: *mut DFTI_DESCRIPTOR_HANDLE,
        domain: DFTI_CONFIG_VALUE,
        many: ::std::os::raw::c_long,
        ...
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn DftiCreateDescriptor_d_1d(
        arg1: *mut DFTI_DESCRIPTOR_HANDLE,
        domain: DFTI_CONFIG_VALUE,
        ...
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn DftiCreateDescriptor_d_md(
        arg1: *mut DFTI_DESCRIPTOR_HANDLE,
        domain: DFTI_CONFIG_VALUE,
        many: ::std::os::raw::c_long,
        ...
    ) -> ::std::os::raw::c_long;
}
